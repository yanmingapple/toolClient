# 工具调用框架使用说明

## 概述

工具调用框架是一个通用的、智能的AI工具系统，**不再需要硬编码提示词**。AI可以自动发现、选择和组合使用各种工具（SQLite、Markdown、Electron功能等）来完成用户请求。

## 核心优势

1. **无需硬编码提示词**：系统提示词基于可用工具动态生成
2. **AI自动选择工具**：根据用户意图自动选择最合适的工具
3. **易于扩展**：新增工具只需注册，无需修改提示词
4. **统一接口**：所有工具使用统一的接口定义
5. **智能组合**：AI可以组合多个工具完成复杂任务

## 架构设计

```
┌─────────────────────────────────────┐
│      AIService (AI服务)             │
│  - 动态生成系统提示词                │
│  - 调用AI（支持Function Calling）   │
│  - 处理工具调用结果                  │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│      ToolRegistry (工具注册表)       │
│  - 自动注册所有工具                  │
│  - 提供工具描述给AI                  │
│  - 执行工具调用                      │
└──────────────┬──────────────────────┘
               │
    ┌──────────┴──────────┐
    │                     │
┌───▼────┐          ┌─────▼─────┐
│数据库工具│          │记忆系统工具│
│SQLite  │          │Markdown   │
└────────┘          └───────────┘
```

## 已注册的工具

### 数据库工具
- `query_sqlite`: 执行SQLite数据库查询
- `get_all_events`: 获取所有事件数据
- `get_events_by_date`: 根据日期获取事件
- `get_all_todos`: 获取所有代办数据
- `get_todos_by_date`: 根据日期获取代办

### 记忆系统工具
- `read_today_log`: 读取今日工作日志
- `read_log_by_date`: 读取指定日期日志
- `search_memory`: 搜索记忆内容
- `read_work_patterns`: 读取工作模式
- `read_best_times`: 读取最佳工作时间
- `read_task_preferences`: 读取任务偏好

### 事件和代办工具
- `create_event`: 创建新事件
- `update_event`: 更新事件
- `delete_event`: 删除事件
- `create_todo`: 创建新代办
- `update_todo`: 更新代办
- `delete_todo`: 删除代办

### 文件系统工具
- `read_file`: 读取文件内容

### 系统工具
- `get_current_date`: 获取当前日期
- `get_current_time`: 获取当前时间
- `calculate_date_offset`: 计算日期偏移

## 使用方法

### 方法1：使用工具调用框架（推荐）

```typescript
// 使用新的工具调用方法
const result = await aiService.parseNaturalLanguageWithTools(
  "明天下午3点开会",
  { currentDate: '2026-01-30' }
);
```

### 方法2：传统方法（仍然支持）

```typescript
// 传统方法仍然可用，作为降级方案
const result = await aiService.parseNaturalLanguage(
  "明天下午3点开会",
  { currentDate: '2026-01-30' }
);
```

## 工作流程示例

### 示例1：创建事件

**用户输入**："明天下午3点开会"

**AI自动执行**：
1. 调用 `get_current_date` 获取今天日期
2. 调用 `calculate_date_offset` 计算明天日期
3. 调用 `read_work_patterns` 获取用户习惯
4. 调用 `read_best_times` 获取最佳工作时间
5. 调用 `create_event` 创建事件
6. 返回结果

**无需硬编码任何提示词！**

### 示例2：搜索事件

**用户输入**："明天有哪些工作？"

**AI自动执行**：
1. 调用 `get_current_date` 获取今天日期
2. 调用 `calculate_date_offset` 计算明天日期
3. 调用 `get_events_by_date` 获取明天的事件
4. 过滤类型为"工作"的事件
5. 返回匹配结果

### 示例3：智能建议

**用户输入**："帮我安排一个编码任务"

**AI自动执行**：
1. 调用 `read_work_patterns` 获取工作模式
2. 调用 `read_best_times` 获取最佳工作时间
3. 调用 `get_all_events` 查看现有安排
4. 根据用户习惯和现有安排，建议最佳时间
5. 调用 `create_event` 创建事件
6. 返回结果和建议理由

## 添加新工具

### 步骤1：在 ToolRegistry 中注册工具

```typescript
// electron/service/ai/toolRegistry.ts

private registerCustomTools(): void {
  this.registerTool({
    name: 'my_custom_tool',
    description: '工具描述（AI可见）',
    category: 'system',
    parameters: {
      type: 'object',
      properties: {
        param1: {
          type: 'string',
          description: '参数1描述'
        }
      },
      required: ['param1']
    },
    handler: async (args: any) => {
      // 工具执行逻辑
      return { result: 'success' };
    }
  });
}
```

### 步骤2：在 autoRegisterTools 中调用

```typescript
public async autoRegisterTools(): Promise<void> {
  // ... 现有工具注册
  this.registerCustomTools(); // 添加这行
}
```

**就这么简单！** 无需修改任何提示词，AI会自动发现并使用新工具。

## 技术细节

### Function Calling 支持

框架支持 OpenAI 和 DeepSeek 的 Function Calling API：

- **OpenAI**: `gpt-3.5-turbo`, `gpt-4`, `gpt-4-turbo`
- **DeepSeek**: `deepseek-chat`, `deepseek-coder`

### 递归工具调用

AI可以连续调用多个工具，框架会自动处理递归调用（最多5次迭代，防止无限循环）。

### 错误处理

- 工具执行失败时，会返回错误信息给AI
- AI可以根据错误信息选择其他工具或降级处理
- 如果工具调用完全失败，会自动降级到传统模式

## 性能优化

1. **延迟加载**：工具注册表在首次使用时才初始化
2. **工具缓存**：工具列表在会话期间缓存
3. **批量执行**：多个工具调用可以并行执行

## 未来扩展

- [ ] 支持更多AI提供商（百度、阿里、腾讯）
- [ ] 工具使用统计和分析
- [ ] 工具权限控制
- [ ] 工具组合模板
- [ ] 工具执行日志

---

**最后更新**: 2026-01-30
**状态**: ✅ 已实现并可用

